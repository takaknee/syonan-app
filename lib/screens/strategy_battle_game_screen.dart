import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../models/mini_game.dart';
import '../models/strategy_game.dart';
import '../services/mini_game_service.dart';
import '../services/strategy_game_service.dart';

/// Êà¶Áï•„Éê„Éà„É´„Ç≤„Éº„É†ÁîªÈù¢
class StrategyBattleGameScreen extends StatefulWidget {
  const StrategyBattleGameScreen({super.key});

  @override
  State<StrategyBattleGameScreen> createState() =>
      _StrategyBattleGameScreenState();
}

class _StrategyBattleGameScreenState extends State<StrategyBattleGameScreen> {
  final StrategyGameService _gameService = StrategyGameService();
  late StrategyGameState _gameState;
  late DateTime _startTime;
  bool _isGameComplete = false;
  bool _showTutorial = true;

  @override
  void initState() {
    super.initState();
    _startGame();
    // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Çí3ÁßíÂæå„Å´Ëá™ÂãïÁöÑ„Å´Èñâ„Åò„Çã
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted && _showTutorial) {
        setState(() {
          _showTutorial = false;
        });
      }
    });
  }

  void _startGame() {
    setState(() {
      _startTime = DateTime.now();
      _gameState = _gameService.initializeGame();
      _isGameComplete = false;
    });
  }

  void _completeGame() {
    if (_isGameComplete) return;

    setState(() {
      _isGameComplete = true;
    });

    final duration = DateTime.now().difference(_startTime);
    final finalScore = _gameService.calculateFinalScore(_gameState, duration);

    // „Çπ„Ç≥„Ç¢„ÇíË®òÈå≤
    final miniGameService =
        Provider.of<MiniGameService>(context, listen: false);
    miniGameService.recordScore(
        'strategy_battle', finalScore, MiniGameDifficulty.hard);

    _showGameCompleteDialog(finalScore);
  }

  void _showGameCompleteDialog(int finalScore) {
    final isVictory = _gameState.gameStatus == GameStatus.victory;
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: Text(isVictory ? 'üèÜ ÂãùÂà©ÔºÅ' : 'üò¢ ÊïóÂåó...'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: $finalScoreÁÇπ'),
            const SizedBox(height: 8),
            Text('ÊîØÈÖçÈ†òÂúü: ${_gameState.playerTerritoryCount}'),
            const SizedBox(height: 4),
            Text('„Çø„Éº„É≥Êï∞: ${_gameState.currentTurn}'),
            if (isVictory) ...[
              const SizedBox(height: 8),
              const Text('üéâ Êïµ„ÅÆÈ¶ñÈÉΩ„ÇíÂç†È†ò„Åó„Åæ„Åó„ÅüÔºÅ'),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.of(context).pop();
            },
            child: const Text('„Éõ„Éº„É†„Å´Êàª„Çã'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              _restartGame();
            },
            child: const Text('ÂÜçÊà¶'),
          ),
        ],
      ),
    );
  }

  void _restartGame() {
    setState(() {
      _isGameComplete = false;
      _showTutorial = true;
    });
    _startGame();
  }

  void _selectTerritory(String territoryId) {
    setState(() {
      _gameState = _gameState.copyWith(
        selectedTerritoryId: _gameState.selectedTerritoryId == territoryId 
            ? null 
            : territoryId,
      );
    });
  }

  void _attackTerritory(String attackerTerritoryId, String defenderTerritoryId) {
    final attacker = _gameState.getTerritoryById(attackerTerritoryId);
    final defender = _gameState.getTerritoryById(defenderTerritoryId);
    
    if (attacker == null || defender == null) return;
    
    setState(() {
      _gameState = _gameService.attackTerritory(
        _gameState,
        attackerTerritoryId,
        defenderTerritoryId,
      );
    });

    // Êà¶ÈóòÁµêÊûú„ÇíË°®Á§∫
    final conqueredTerritory = _gameState.getTerritoryById(defenderTerritoryId);
    final wasConquered = conqueredTerritory?.owner == Owner.player;
    
    _showBattleResult(defender.name, wasConquered);

    // „Ç≤„Éº„É†ÁµÇ‰∫Ü„ÉÅ„Çß„ÉÉ„ÇØ
    if (_gameState.gameStatus != GameStatus.playing) {
      _completeGame();
    }
  }

  void _showBattleResult(String territoryName, bool victory) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          victory 
            ? 'üéâ $territoryName„ÇíÂç†È†ò„Åó„Åæ„Åó„ÅüÔºÅ'
            : 'üòì $territoryName„ÅÆÊîªÁï•„Å´Â§±Êïó...',
        ),
        backgroundColor: victory ? Colors.green : Colors.red,
        duration: const Duration(seconds: 2),
      ),
    );
  }

  void _recruitTroops(String territoryId, int amount) {
    setState(() {
      _gameState = _gameService.recruitTroops(_gameState, territoryId, amount);
    });
  }

  void _endTurn() {
    setState(() {
      _gameState = _gameService.endTurn(_gameState);
    });

    // „Ç≤„Éº„É†ÁµÇ‰∫Ü„ÉÅ„Çß„ÉÉ„ÇØ
    if (_gameState.gameStatus != GameStatus.playing) {
      _completeGame();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Ê∞¥Êª∏‰ºù - ÂõΩÁõó„ÇäÊà¶Áï•'),
        backgroundColor: const Color(0xFF8BC34A),
        foregroundColor: Colors.white,
        actions: [
          IconButton(
            icon: const Icon(Icons.help_outline),
            onPressed: () => setState(() => _showTutorial = true),
          ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _restartGame,
          ),
        ],
      ),
      body: Stack(
        children: [
          Column(
            children: [
              // „Ç≤„Éº„É†ÊÉÖÂ†±„Éë„Éç„É´
              _buildGameInfoPanel(),
              // „Éû„ÉÉ„ÉóË°®Á§∫
              Expanded(
                flex: 3,
                child: _buildGameMap(),
              ),
              // „Ç¢„ÇØ„Ç∑„Éß„É≥„Éë„Éç„É´
              Expanded(
                child: _buildActionPanel(),
              ),
            ],
          ),
          if (_showTutorial) _buildTutorialOverlay(),
        ],
      ),
    );
  }

  Widget _buildGameInfoPanel() {
    final totalTerritories = _gameState.territories.length;
    final playerPercent = _gameState.playerTerritoryCount / totalTerritories;
    final enemyPercent = _gameState.enemyTerritoryCount / totalTerritories;
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFF8BC34A).withValues(alpha: 0.1),
        border: const Border(bottom: BorderSide(color: Colors.grey, width: 0.5)),
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildInfoItem('üí∞', '${_gameState.playerGold}', 'Èáë'),
              _buildInfoItem('‚öîÔ∏è', '${_gameState.playerTroops}', 'ÂÖµÂäõ'),
              _buildInfoItem('üè∞', '${_gameState.playerTerritoryCount}', 'È†òÂúü'),
              _buildInfoItem('üìÖ', '${_gameState.currentTurn}/${StrategyGameService.maxTurns}', '„Çø„Éº„É≥'),
            ],
          ),
          const SizedBox(height: 8),
          // ÊîØÈÖçÁä∂Ê≥Å„ÇíË°®Á§∫
          Row(
            children: [
              const Text('ÊîØÈÖçÁä∂Ê≥Å: ', style: TextStyle(fontSize: 12)),
              Expanded(
                child: LinearProgressIndicator(
                  value: playerPercent,
                  backgroundColor: Colors.red.withValues(alpha: 0.3),
                  valueColor: const AlwaysStoppedAnimation<Color>(Colors.green),
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${(_gameState.playerTerritoryCount / totalTerritories * 100).round()}%',
                style: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoItem(String emoji, String value, String label) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(emoji, style: const TextStyle(fontSize: 20)),
        const SizedBox(height: 4),
        Text(
          value,
          style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
        ),
        Text(
          label,
          style: const TextStyle(fontSize: 12, color: Colors.grey),
        ),
      ],
    );
  }

  Widget _buildGameMap() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: GridView.builder(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: StrategyGameService.mapWidth,
          crossAxisSpacing: 4,
          mainAxisSpacing: 4,
        ),
        itemCount: _gameState.territories.length,
        itemBuilder: (context, index) {
          final territory = _gameState.territories[index];
          return _buildTerritoryTile(territory);
        },
      ),
    );
  }

  Widget _buildTerritoryTile(Territory territory) {
    final isSelected = _gameState.selectedTerritoryId == territory.id;
    final isPlayerTerritory = territory.owner == Owner.player;
    final isEnemyTerritory = territory.owner == Owner.enemy;
    final canAttack = isSelected && isPlayerTerritory && 
                     _gameService.getAttackableTargets(_gameState, territory.id).isNotEmpty;
    
    Color backgroundColor;
    Color borderColor;
    String ownerEmoji;
    
    if (isPlayerTerritory) {
      backgroundColor = const Color(0xFF4CAF50);
      borderColor = isSelected ? Colors.lightBlue : Colors.green;
      ownerEmoji = 'üü¢';
    } else if (isEnemyTerritory) {
      backgroundColor = const Color(0xFFF44336);
      borderColor = isSelected ? Colors.lightBlue : Colors.red;
      ownerEmoji = 'üî¥';
    } else {
      backgroundColor = const Color(0xFF9E9E9E);
      borderColor = isSelected ? Colors.lightBlue : Colors.grey;
      ownerEmoji = '‚ö™';
    }

    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      child: GestureDetector(
        onTap: () => _selectTerritory(territory.id),
        child: Container(
          decoration: BoxDecoration(
            color: backgroundColor.withValues(alpha: isSelected ? 1.0 : 0.8),
            border: Border.all(
              color: borderColor, 
              width: isSelected ? 3 : 1
            ),
            borderRadius: BorderRadius.circular(8),
            boxShadow: isSelected ? [
              BoxShadow(
                color: borderColor.withValues(alpha: 0.3),
                spreadRadius: 2,
                blurRadius: 4,
              )
            ] : null,
          ),
          child: Stack(
            children: [
              if (canAttack)
                Positioned(
                  top: 2,
                  right: 2,
                  child: Container(
                    width: 12,
                    height: 12,
                    decoration: const BoxDecoration(
                      color: Colors.orange,
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.flash_on,
                      size: 8,
                      color: Colors.white,
                    ),
                  ),
                ),
              Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        if (territory.isCapital) ...[
                          const Text('üëë', style: TextStyle(fontSize: 14)),
                          const SizedBox(width: 2),
                        ],
                        Text(ownerEmoji, style: const TextStyle(fontSize: 12)),
                      ],
                    ),
                    const SizedBox(height: 2),
                    Text(
                      territory.name,
                      style: const TextStyle(
                        fontSize: 9,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                      textAlign: TextAlign.center,
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                    const SizedBox(height: 1),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
                      decoration: BoxDecoration(
                        color: Colors.black.withValues(alpha: 0.3),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        '‚öîÔ∏è${territory.troops}',
                        style: const TextStyle(
                          fontSize: 11,
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildActionPanel() {
    final selectedTerritory = _gameState.selectedTerritory;
    
    if (selectedTerritory == null) {
      return Container(
        padding: const EdgeInsets.all(16),
        child: const Center(
          child: Text(
            'È†òÂúü„Çí„Çø„ÉÉ„Éó„Åó„Å¶ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            style: TextStyle(fontSize: 16, color: Colors.grey),
          ),
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text(
            'ÈÅ∏Êäû‰∏≠: ${selectedTerritory.name}',
            style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (selectedTerritory.owner == Owner.player) ...[
            _buildPlayerTerritoryActions(selectedTerritory),
          ] else ...[
            _buildEnemyTerritoryActions(selectedTerritory),
          ],
          const SizedBox(height: 8),
          ElevatedButton(
            onPressed: _endTurn,
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF8BC34A),
              foregroundColor: Colors.white,
            ),
            child: const Text('„Çø„Éº„É≥ÁµÇ‰∫Ü'),
          ),
        ],
      ),
    );
  }

  Widget _buildPlayerTerritoryActions(Territory territory) {
    final canRecruit = _gameState.playerGold >= StrategyGameService.troopCost &&
                      territory.troops < territory.maxTroops;
    
    return Column(
      children: [
        Row(
          children: [
            Text('ÂÖµÂäõ: ${territory.troops}/${territory.maxTroops}'),
            const Spacer(),
            Text('Ë≥áÊ∫ê: ${territory.resources}'),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: ElevatedButton(
                onPressed: canRecruit ? () => _recruitTroops(territory.id, 1) : null,
                child: const Text('ÂÖµÂ£´ÂãüÈõÜ (${StrategyGameService.troopCost}Èáë)'),
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        ..._buildAttackButtons(territory),
      ],
    );
  }

  Widget _buildEnemyTerritoryActions(Territory territory) {
    return Column(
      children: [
        Text('ÊïµÈ†òÂúü - ÂÖµÂäõ: ${territory.troops}'),
        if (territory.isCapital)
          const Text('üëë Êïµ„ÅÆÈ¶ñÈÉΩÔºÅ', style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
      ],
    );
  }

  List<Widget> _buildAttackButtons(Territory territory) {
    final attackableTargets = _gameService.getAttackableTargets(_gameState, territory.id);
    
    if (attackableTargets.isEmpty || territory.troops <= 1) {
      return [const Text('ÊîªÊíÉÂèØËÉΩ„Å™Êïµ„Åå„ÅÑ„Åæ„Åõ„Çì', style: TextStyle(color: Colors.grey))];
    }

    return attackableTargets.map((target) {
      return Padding(
        padding: const EdgeInsets.only(top: 4),
        child: ElevatedButton(
          onPressed: () => _attackTerritory(territory.id, target.id),
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
          ),
          child: Text('${target.name}„ÇíÊîªÊíÉ (ÂÖµÂäõ${target.troops})'),
        ),
      );
    }).toList();
  }

  Widget _buildTutorialOverlay() {
    return Container(
      color: Colors.black.withValues(alpha: 0.8),
      child: Center(
        child: Card(
          margin: const EdgeInsets.all(20),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  'üè∞ Ê∞¥Êª∏‰ºù ÂõΩÁõó„ÇäÊà¶Áï• üè∞',
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 16),
                const Text(
                  'ÁõÆÊ®ô: Êïµ„ÅÆÈ¶ñÈÉΩÔºàüëëÔºâ„ÇíÂç†È†ò„Åõ„ÇàÔºÅ\n\n'
                  'üü¢ = „ÅÇ„Å™„Åü„ÅÆÈ†òÂúü\n'
                  'üî¥ = Êïµ„ÅÆÈ†òÂúü\n'
                  '‚ö™ = ‰∏≠Á´ã„ÅÆÈ†òÂúü\n\n'
                  '1. È†òÂúü„Çí„Çø„ÉÉ„Éó„Åó„Å¶ÈÅ∏Êäû\n'
                  '2. Èö£Êé•„Åô„ÇãÊïµÈ†òÂúü„ÇíÊîªÊíÉ\n'
                  '3. Èáë„ÅßÂÖµÂ£´„ÇíÂãüÈõÜ\n'
                  '4. „Çø„Éº„É≥ÁµÇ‰∫Ü„ÅßË≥áÊ∫êÁç≤Âæó',
                  textAlign: TextAlign.center,
                  style: TextStyle(fontSize: 14),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => setState(() => _showTutorial = false),
                  child: const Text('„Ç≤„Éº„É†ÈñãÂßãÔºÅ'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
