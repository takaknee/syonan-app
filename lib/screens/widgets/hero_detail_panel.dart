/// Ëã±ÈõÑË©≥Á¥∞„Éª„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Éë„Éç„É´
library;

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../controllers/water_margin_game_controller.dart';
import '../../models/hero_advancement.dart';
import '../../models/water_margin_strategy_game.dart' as game;

/// Ëã±ÈõÑË©≥Á¥∞„Éë„Éç„É´
class HeroDetailPanel extends StatefulWidget {
  const HeroDetailPanel({
    super.key,
    required this.hero,
  });

  final game.Hero hero;

  @override
  State<HeroDetailPanel> createState() => _HeroDetailPanelState();
}

class _HeroDetailPanelState extends State<HeroDetailPanel> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<WaterMarginGameController>(
      builder: (context, controller, child) {
        final advancement = controller.getAdvancedHero(widget.hero.id);

        return Card(
          child: Column(
            children: [
              // „Éò„ÉÉ„ÉÄ„Éº
              _HeroDetailHeader(
                hero: widget.hero,
                advancement: advancement,
              ),

              // „Çø„Éñ„Éê„Éº
              TabBar(
                controller: _tabController,
                tabs: const [
                  Tab(
                    icon: Icon(Icons.person),
                    text: 'Âü∫Êú¨ÊÉÖÂ†±',
                  ),
                  Tab(
                    icon: Icon(Icons.star),
                    text: '„É¨„Éô„É´„Éª„Çπ„Ç≠„É´',
                  ),
                  Tab(
                    icon: Icon(Icons.inventory),
                    text: 'Ë£ÖÂÇô',
                  ),
                ],
              ),

              // „Çø„Éñ„Éì„É•„Éº
              Expanded(
                child: TabBarView(
                  controller: _tabController,
                  children: [
                    // Âü∫Êú¨ÊÉÖÂ†±„Çø„Éñ
                    _HeroBasicInfoTab(hero: widget.hero),

                    // „É¨„Éô„É´„Éª„Çπ„Ç≠„É´„Çø„Éñ
                    _HeroLevelSkillTab(
                      hero: widget.hero,
                      advancement: advancement,
                      controller: controller,
                    ),

                    // Ë£ÖÂÇô„Çø„Éñ
                    _HeroEquipmentTab(
                      hero: widget.hero,
                      advancement: advancement,
                      controller: controller,
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

/// Ëã±ÈõÑË©≥Á¥∞„Éò„ÉÉ„ÉÄ„Éº
class _HeroDetailHeader extends StatelessWidget {
  const _HeroDetailHeader({
    required this.hero,
    this.advancement,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;

  @override
  Widget build(BuildContext context) {
    final level = advancement?.advancedStats.level ?? 1;
    final totalExperience = advancement?.advancedStats.experience.values.fold(0, (sum, exp) => sum + exp) ?? 0;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            hero.faction.factionColor.withValues(alpha: 0.8),
            hero.faction.factionColor.withValues(alpha: 0.6),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
      ),
      child: Column(
        children: [
          Row(
            children: [
              // Ëã±ÈõÑ„Ç¢„Ç§„Ç≥„É≥
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.white.withValues(alpha: 0.9),
                  borderRadius: BorderRadius.circular(50),
                ),
                child: Text(
                  hero.skillIcon,
                  style: const TextStyle(fontSize: 32),
                ),
              ),
              const SizedBox(width: 16),

              // Ëã±ÈõÑÊÉÖÂ†±
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      hero.name,
                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    Text(
                      hero.nickname,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            color: Colors.white.withValues(alpha: 0.9),
                          ),
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Text(
                          'Lv.$level',
                          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                        ),
                        const SizedBox(width: 16),
                        Text(
                          hero.skillDescription,
                          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                color: Colors.white.withValues(alpha: 0.8),
                              ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              // „Çπ„ÉÜ„Éº„Çø„Çπ
              if (hero.isRecruited)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.green.withValues(alpha: 0.8),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: const Text(
                    '‰ª≤Èñì',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
            ],
          ),

          // ÁµåÈ®ìÂÄ§„Éê„Éº
          if (hero.isRecruited) const SizedBox(height: 16),
          if (hero.isRecruited)
            _ExperienceBar(
              currentExp: totalExperience,
              level: level,
            ),
        ],
      ),
    );
  }
}

/// ÁµåÈ®ìÂÄ§„Éê„Éº
class _ExperienceBar extends StatelessWidget {
  const _ExperienceBar({
    required this.currentExp,
    required this.level,
  });

  final int currentExp;
  final int level;

  @override
  Widget build(BuildContext context) {
    final currentLevelExp = _getExperienceRequirement(level);
    final nextLevelExp = _getExperienceRequirement(level + 1);
    final expInCurrentLevel = currentExp - currentLevelExp;
    final expNeededForLevel = nextLevelExp - currentLevelExp;
    final progress = expInCurrentLevel / expNeededForLevel;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'EXP: $expInCurrentLevel / $expNeededForLevel',
              style: TextStyle(
                color: Colors.white.withValues(alpha: 0.9),
                fontSize: 12,
              ),
            ),
            Text(
              'Ê¨°„ÅÆ„É¨„Éô„É´„Åæ„Åß: ${expNeededForLevel - expInCurrentLevel}',
              style: TextStyle(
                color: Colors.white.withValues(alpha: 0.9),
                fontSize: 12,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        LinearProgressIndicator(
          value: progress.clamp(0.0, 1.0),
          backgroundColor: Colors.white.withValues(alpha: 0.3),
          valueColor: const AlwaysStoppedAnimation<Color>(Colors.yellow),
        ),
      ],
    );
  }

  int _getExperienceRequirement(int level) {
    if (level <= 1) return 0;
    return (level - 1) * (level - 1) * 100;
  }
}

/// Âü∫Êú¨ÊÉÖÂ†±„Çø„Éñ
class _HeroBasicInfoTab extends StatelessWidget {
  const _HeroBasicInfoTab({required this.hero});

  final game.Hero hero;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ËÉΩÂäõÂÄ§Ë°®Á§∫
          _StatDisplaySection(hero: hero),
          const SizedBox(height: 24),

          // ÁèæÂú®„ÅÆÈÖçÁΩÆ
          _HeroLocationSection(hero: hero),
          const SizedBox(height: 24),

          // Ëã±ÈõÑË™¨Êòé
          _HeroDescriptionSection(hero: hero),
        ],
      ),
    );
  }
}

/// ËÉΩÂäõÂÄ§Ë°®Á§∫„Çª„ÇØ„Ç∑„Éß„É≥
class _StatDisplaySection extends StatelessWidget {
  const _StatDisplaySection({required this.hero});

  final game.Hero hero;

  @override
  Widget build(BuildContext context) {
    final stats = hero.stats;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '‚≠ê ËÉΩÂäõÂÄ§',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            _StatBar(label: 'Áµ±Áéá', value: stats.leadership, icon: 'üëë'),
            _StatBar(label: 'Ê≠¶Âäõ', value: stats.force, icon: '‚öîÔ∏è'),
            _StatBar(label: 'Áü•Âäõ', value: stats.intelligence, icon: 'üß†'),
            _StatBar(label: 'È≠ÖÂäõ', value: stats.charisma, icon: '‚ú®'),
            _StatBar(label: 'Áæ©ÁêÜ', value: stats.loyalty, icon: '‚ù§Ô∏è'),
          ],
        ),
      ),
    );
  }
}

/// ËÉΩÂäõÂÄ§„Éê„Éº
class _StatBar extends StatelessWidget {
  const _StatBar({
    required this.label,
    required this.value,
    required this.icon,
  });

  final String label;
  final int value;
  final String icon;

  @override
  Widget build(BuildContext context) {
    final percentage = value / 100.0;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(icon),
              const SizedBox(width: 8),
              Text(
                label,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const Spacer(),
              Text(
                '$value',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          LinearProgressIndicator(
            value: percentage,
            backgroundColor: Colors.grey.shade300,
            valueColor: AlwaysStoppedAnimation<Color>(
              percentage >= 0.8
                  ? Colors.orange
                  : percentage >= 0.6
                      ? Colors.blue
                      : Colors.green,
            ),
          ),
        ],
      ),
    );
  }
}

/// Ëã±ÈõÑÈÖçÁΩÆ„Çª„ÇØ„Ç∑„Éß„É≥
class _HeroLocationSection extends StatelessWidget {
  const _HeroLocationSection({required this.hero});

  final game.Hero hero;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'üìç ÁèæÂú®„ÅÆÈÖçÁΩÆ',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            Text(
              hero.currentProvinceId != null ? '${hero.currentProvinceId}„Å´ÈÖçÁΩÆ‰∏≠' : 'Êú™ÈÖçÁΩÆ',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  hero.isRecruited ? Icons.check_circle : Icons.help_outline,
                  color: hero.isRecruited ? Colors.green : Colors.orange,
                ),
                const SizedBox(width: 8),
                Text(
                  hero.isRecruited ? 'Ê¢ÅÂ±±Ê≥ä„ÅÆ‰ª≤Èñì' : 'Êú™Âä†ÂÖ•',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// Ëã±ÈõÑË™¨Êòé„Çª„ÇØ„Ç∑„Éß„É≥
class _HeroDescriptionSection extends StatelessWidget {
  const _HeroDescriptionSection({required this.hero});

  final game.Hero hero;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'üìú ‰∫∫Áâ©Á¥π‰ªã',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            Text(
              _getHeroDescription(hero),
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ),
      ),
    );
  }

  String _getHeroDescription(game.Hero hero) {
    // TODO: ÂÆüÈöõ„ÅÆËã±ÈõÑË™¨Êòé„Éá„Éº„Çø„ÇíÂÆüË£Ö
    return '${hero.name}Ôºà${hero.nickname}Ôºâ„ÅØ${hero.skillDescription}„Å®„Åó„Å¶Ê¥ªË∫ç„Åô„ÇãËã±ÈõÑ„Åß„Åô„ÄÇ'
        '„Åù„ÅÆÂçìË∂ä„Åó„ÅüËÉΩÂäõ„ÅßÊ¢ÅÂ±±Ê≥ä„ÅÆÁô∫Â±ï„Å´Ë≤¢ÁåÆ„Åô„Çã„Åì„Å®„ÅåÊúüÂæÖ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ';
  }
}

/// „É¨„Éô„É´„Éª„Çπ„Ç≠„É´„Çø„Éñ
class _HeroLevelSkillTab extends StatelessWidget {
  const _HeroLevelSkillTab({
    required this.hero,
    this.advancement,
    required this.controller,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    if (!hero.isRecruited) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.lock, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              '‰ª≤Èñì„Å´„Å™„Å£„Å¶„Åã„Çâ\n„É¨„Éô„É´„Ç¢„ÉÉ„Éó„ÅåÂèØËÉΩ„Åß„Åô',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Çª„ÇØ„Ç∑„Éß„É≥
          _LevelUpSection(
            hero: hero,
            advancement: advancement,
            controller: controller,
          ),
          const SizedBox(height: 24),

          // ÁøíÂæóÊ∏à„Åø„Çπ„Ç≠„É´„Çª„ÇØ„Ç∑„Éß„É≥
          _LearnedSkillsSection(
            hero: hero,
            advancement: advancement,
          ),
          const SizedBox(height: 24),

          // ÁøíÂæóÂèØËÉΩ„Çπ„Ç≠„É´„Çª„ÇØ„Ç∑„Éß„É≥
          _AvailableSkillsSection(
            hero: hero,
            advancement: advancement,
            controller: controller,
          ),
        ],
      ),
    );
  }
}

/// „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Çª„ÇØ„Ç∑„Éß„É≥
class _LevelUpSection extends StatelessWidget {
  const _LevelUpSection({
    required this.hero,
    this.advancement,
    required this.controller,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    final level = advancement?.advancedStats.level ?? 1;
    final totalExperience = advancement?.advancedStats.experience.values.fold(0, (sum, exp) => sum + exp) ?? 0;
    final canLevelUp = _canLevelUp(level, totalExperience);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  '‚¨ÜÔ∏è „É¨„Éô„É´„Ç¢„ÉÉ„Éó',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                const Spacer(),
                if (canLevelUp)
                  ElevatedButton.icon(
                    onPressed: () => _showLevelUpConfirmation(context),
                    icon: const Icon(Icons.arrow_upward),
                    label: const Text('„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.orange,
                      foregroundColor: Colors.white,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),

            // ÁèæÂú®„ÅÆ„É¨„Éô„É´ÊÉÖÂ†±
            Row(
              children: [
                Text('ÁèæÂú®„É¨„Éô„É´: $level'),
                const SizedBox(width: 24),
                Text('ÁµåÈ®ìÂÄ§: $totalExperience'),
              ],
            ),
            const SizedBox(height: 8),

            // „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÊôÇ„ÅÆ„Éú„Éº„Éä„ÇπË°®Á§∫
            if (canLevelUp) ...[
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.orange.shade200),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '„É¨„Éô„É´${level + 1}„Å∏„ÅÆÊòáÊ†º„ÅßÂæó„Çâ„Çå„Çã„Éú„Éº„Éä„Çπ:',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Colors.orange.shade700,
                      ),
                    ),
                    const SizedBox(height: 8),
                    const Text('‚Ä¢ ÂÖ®ËÉΩÂäõÂÄ§ +2'),
                    const Text('‚Ä¢ „Çπ„Ç≠„É´„Éù„Ç§„É≥„Éà +1'),
                    const Text('‚Ä¢ Êñ∞„Åó„ÅÑ„Çπ„Ç≠„É´ÁøíÂæóÊ©ü‰ºö'),
                  ],
                ),
              ),
            ] else ...[
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  'Ê¨°„ÅÆ„É¨„Éô„É´„Åæ„Åß: ${_getExperienceToNext(level, totalExperience)} ÁµåÈ®ìÂÄ§',
                  style: TextStyle(color: Colors.grey.shade600),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  bool _canLevelUp(int level, int experience) {
    final nextLevelExp = _getExperienceRequirement(level + 1);
    return experience >= nextLevelExp && level < 50;
  }

  int _getExperienceToNext(int level, int experience) {
    final nextLevelExp = _getExperienceRequirement(level + 1);
    return (nextLevelExp - experience).clamp(0, double.infinity).toInt();
  }

  int _getExperienceRequirement(int level) {
    if (level <= 1) return 0;
    return (level - 1) * (level - 1) * 100;
  }

  void _showLevelUpConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('„É¨„Éô„É´„Ç¢„ÉÉ„Éó'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('${hero.name}„Çí„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Åæ„Åô„ÅãÔºü'),
            const SizedBox(height: 16),
            const Text('Áç≤Âæó„Éú„Éº„Éä„Çπ:'),
            const Text('‚Ä¢ ÂÖ®ËÉΩÂäõÂÄ§ +2'),
            const Text('‚Ä¢ „Çπ„Ç≠„É´„Éù„Ç§„É≥„Éà +1'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('„Ç≠„É£„É≥„Çª„É´'),
          ),
          ElevatedButton(
            onPressed: () {
              // ÁµåÈ®ìÂÄ§„Çí‰ªò‰∏é„Åó„Å¶„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Çí‰øÉÈÄ≤
              final controller = Provider.of<WaterMarginGameController>(context, listen: false);
              controller.addExperience(hero.id, 200, ExperienceType.combat);
              Navigator.of(context).pop();
              _showLevelUpSuccess(context);
            },
            child: const Text('„É¨„Éô„É´„Ç¢„ÉÉ„Éó'),
          ),
        ],
      ),
    );
  }

  void _showLevelUpSuccess(BuildContext context) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('${hero.name}„Åå„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Åæ„Åó„ÅüÔºÅ'),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

/// ÁøíÂæóÊ∏à„Åø„Çπ„Ç≠„É´„Çª„ÇØ„Ç∑„Éß„É≥
class _LearnedSkillsSection extends StatelessWidget {
  const _LearnedSkillsSection({
    required this.hero,
    this.advancement,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;

  @override
  Widget build(BuildContext context) {
    final learnedSkills = _getLearnedSkills();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'üéØ ÁøíÂæóÊ∏à„Åø„Çπ„Ç≠„É´',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            if (learnedSkills.isEmpty)
              Container(
                padding: const EdgeInsets.all(16),
                width: double.infinity,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Text(
                  '„Åæ„Å†„Çπ„Ç≠„É´„ÇíÁøíÂæó„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì',
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey),
                ),
              )
            else
              ...learnedSkills.map((skill) => _SkillCard(
                    skill: skill,
                    isLearned: true,
                  )),
          ],
        ),
      ),
    );
  }

  List<Map<String, dynamic>> _getLearnedSkills() {
    if (advancement == null) return [];
    
    return advancement!.advancedStats.skills.map((skill) => {
      'name': _getSkillDisplayName(skill),
      'description': _getSkillDescription(skill),
      'icon': _getSkillIcon(skill),
      'effect': _getSkillEffect(skill),
    }).toList();
  }

  // „Çπ„Ç≠„É´Ë°®Á§∫Áî®„ÅÆ„Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„ÉâÁæ§Ôºà_LearnedSkillsSection„Å®ÂÖ±ÈÄöÔºâ
  String _getSkillDisplayName(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'ÁãÇÊà¶Â£´';
      case HeroLevelSkill.tactician:
        return 'Êà¶Ë°ìÂÆ∂';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°Âêç‰∫∫';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÂ∞ÇÈñÄÂÆ∂';
      case HeroLevelSkill.administrator:
        return 'Ë°åÊîøÂÆò';
      case HeroLevelSkill.economist:
        return 'ÁµåÊ∏àÂ≠¶ËÄÖ';
      case HeroLevelSkill.engineer:
        return 'ÊäÄË°ìËÄÖ';
      case HeroLevelSkill.scholar:
        return 'Â≠¶ËÄÖ';
      case HeroLevelSkill.negotiator:
        return '‰∫§Ê∏â‰∫∫';
      case HeroLevelSkill.spy:
        return 'Ë´úÂ†±Âì°';
      case HeroLevelSkill.ambassador:
        return 'Â§ß‰Ωø';
      case HeroLevelSkill.inspiring:
        return 'ÈºìËàû';
      case HeroLevelSkill.strategist:
        return 'Êà¶Áï•ÂÆ∂';
      case HeroLevelSkill.trainer:
        return 'Ë®ìÁ∑¥ÂÆò';
    }
  }

  String _getSkillDescription(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'Êà¶ÈóòÊôÇ„Å´ÁãÇÊà¶Â£´„ÅÆÂäõ„ÇíÁô∫ÊèÆ';
      case HeroLevelSkill.tactician:
        return 'ÈÉ®Èöä„ÅÆÊà¶Ë°ìÊåáÊèÆ„Å´Èï∑„Åë„Çã';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°„ÅÆÈÅî‰∫∫';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÊà¶„ÅÆ„Ç®„Ç≠„Çπ„Éë„Éº„Éà';
      case HeroLevelSkill.administrator:
        return 'ÂÑ™ÁßÄ„Å™Ë°åÊîøÊâãËÖï„ÇíÊåÅ„Å§';
      case HeroLevelSkill.economist:
        return 'ÁµåÊ∏àÊîøÁ≠ñ„Å´Á≤æÈÄö';
      case HeroLevelSkill.engineer:
        return 'Âª∫Ë®≠„ÉªÊäÄË°ìÈñãÁô∫„ÅÆÂ∞ÇÈñÄÂÆ∂';
      case HeroLevelSkill.scholar:
        return 'Â≠¶Âïè„ÉªÁ†îÁ©∂„ÅÆÁ¨¨‰∏Ä‰∫∫ËÄÖ';
      case HeroLevelSkill.negotiator:
        return 'Â§ñ‰∫§‰∫§Ê∏â„ÅÆÂêçÊâã';
      case HeroLevelSkill.spy:
        return 'Ë´úÂ†±Ê¥ªÂãï„ÅÆ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´';
      case HeroLevelSkill.ambassador:
        return 'ÂêåÁõüÈñ¢‰øÇ„ÅÆÁ∂≠ÊåÅ„Å´Èï∑„Åë„Çã';
      case HeroLevelSkill.inspiring:
        return 'ÈÉ®‰∏ã„ÅÆÂ£´Ê∞ó„ÇíÈ´ò„ÇÅ„Çã';
      case HeroLevelSkill.strategist:
        return 'Â§ßÂ±ÄÁöÑÊà¶Áï•„ÅÆÁ´ãÊ°àËÄÖ';
      case HeroLevelSkill.trainer:
        return 'ÂÖµÂ£´„ÅÆË®ìÁ∑¥ÊåáÂ∞éËÄÖ';
    }
  }

  String _getSkillIcon(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return '‚ö°';
      case HeroLevelSkill.tactician:
        return 'üéØ';
      case HeroLevelSkill.duelMaster:
        return '‚öîÔ∏è';
      case HeroLevelSkill.siegeExpert:
        return 'üè∞';
      case HeroLevelSkill.administrator:
        return 'üìã';
      case HeroLevelSkill.economist:
        return 'üí∞';
      case HeroLevelSkill.engineer:
        return '‚öôÔ∏è';
      case HeroLevelSkill.scholar:
        return 'üìö';
      case HeroLevelSkill.negotiator:
        return 'ü§ù';
      case HeroLevelSkill.spy:
        return 'üïµÔ∏è';
      case HeroLevelSkill.ambassador:
        return 'üèõÔ∏è';
      case HeroLevelSkill.inspiring:
        return '‚ú®';
      case HeroLevelSkill.strategist:
        return 'üß†';
      case HeroLevelSkill.trainer:
        return 'üèãÔ∏è';
    }
  }

  String _getSkillEffect(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'Êà¶ÈóòÂäõ+20%';
      case HeroLevelSkill.tactician:
        return 'ÈÉ®ÈöäÊåáÊèÆ+30%';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°ÂãùÁéá+50%';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÊà¶+40%';
      case HeroLevelSkill.administrator:
        return 'ÂÜÖÊîøÂäπÁéá+25%';
      case HeroLevelSkill.economist:
        return 'ÂèéÂÖ•+20%';
      case HeroLevelSkill.engineer:
        return 'Âª∫Ë®≠ÈÄüÂ∫¶+30%';
      case HeroLevelSkill.scholar:
        return 'Á†îÁ©∂ÈÄüÂ∫¶+25%';
      case HeroLevelSkill.negotiator:
        return 'Â§ñ‰∫§ÊàêÂäüÁéá+30%';
      case HeroLevelSkill.spy:
        return 'ÊÉÖÂ†±ÂèéÈõÜ+40%';
      case HeroLevelSkill.ambassador:
        return 'ÂêåÁõüÁ∂≠ÊåÅ+25%';
      case HeroLevelSkill.inspiring:
        return 'ÈÉ®ÈöäÂ£´Ê∞ó+20%';
      case HeroLevelSkill.strategist:
        return 'ÂÖ®‰ΩìÊà¶Áï•+15%';
      case HeroLevelSkill.trainer:
        return 'ÂÖµÂ£´ÊàêÈï∑+25%';
    }
  }
}

/// ÁøíÂæóÂèØËÉΩ„Çπ„Ç≠„É´„Çª„ÇØ„Ç∑„Éß„É≥
class _AvailableSkillsSection extends StatelessWidget {
  const _AvailableSkillsSection({
    required this.hero,
    this.advancement,
    required this.controller,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    final level = advancement?.advancedStats.level ?? 1;
    // „Çπ„Ç≠„É´„Éù„Ç§„É≥„Éà„ÅØ‰ªÆÂÆüË£ÖÔºö„É¨„Éô„É´5„Åî„Å®„Å´1„Éù„Ç§„É≥„Éà„ÄÅ„Åô„Åß„Å´ÁøíÂæó„Åó„Åü„Çπ„Ç≠„É´ÂàÜ„ÇíÊ∏õÁÆó
    final maxSkillPoints = (level / 5).floor();
    final usedSkillPoints = advancement?.advancedStats.skills.length ?? 0;
    final skillPoints = maxSkillPoints - usedSkillPoints;
    final availableSkills = _getAvailableSkills(level);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  'üìö ÁøíÂæóÂèØËÉΩ„Çπ„Ç≠„É´',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                const Spacer(),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.blue.shade100,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Text(
                    'SP: $skillPoints',
                    style: TextStyle(
                      color: Colors.blue.shade700,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (availableSkills.isEmpty)
              Container(
                padding: const EdgeInsets.all(16),
                width: double.infinity,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Text(
                  '„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Å¶Êñ∞„Åó„ÅÑ„Çπ„Ç≠„É´„ÇíËß£Êîæ„Åó„Åæ„Åó„Çá„ÅÜ',
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey),
                ),
              )
            else
              ...availableSkills.map((skill) => _SkillCard(
                    skill: skill,
                    isLearned: false,
                    canLearn: skillPoints >= (skill['cost'] ?? 1),
                    onLearn: () => _learnSkill(context, skill),
                  )),
          ],
        ),
      ),
    );
  }

  List<Map<String, dynamic>> _getAvailableSkills(int level) {
    final learnedSkills = advancement?.advancedStats.skills ?? <HeroLevelSkill>{};
    final skills = <Map<String, dynamic>>[];

    // „É¨„Éô„É´„Å´Âøú„Åò„Å¶ÁøíÂæóÂèØËÉΩ„Å™„Çπ„Ç≠„É´„ÇíÂÆöÁæ©
    final availableSkillsByLevel = <int, List<HeroLevelSkill>>{
      5: [HeroLevelSkill.berserker, HeroLevelSkill.administrator],
      10: [HeroLevelSkill.tactician, HeroLevelSkill.economist],
      15: [HeroLevelSkill.duelMaster, HeroLevelSkill.engineer],
      20: [HeroLevelSkill.siegeExpert, HeroLevelSkill.scholar],
      25: [HeroLevelSkill.negotiator, HeroLevelSkill.inspiring],
      30: [HeroLevelSkill.spy, HeroLevelSkill.strategist],
      35: [HeroLevelSkill.ambassador, HeroLevelSkill.trainer],
    };

    // ÁèæÂú®„ÅÆ„É¨„Éô„É´„ÅßÁøíÂæóÂèØËÉΩ„Åß„ÄÅ„Åæ„Å†ÁøíÂæó„Åó„Å¶„ÅÑ„Å™„ÅÑ„Çπ„Ç≠„É´„ÇíÂèñÂæó
    for (final entry in availableSkillsByLevel.entries) {
      if (level >= entry.key) {
        for (final skill in entry.value) {
          if (!learnedSkills.contains(skill)) {
            skills.add({
              'skill': skill,
              'name': _getSkillDisplayName(skill),
              'description': _getSkillDescription(skill),
              'icon': _getSkillIcon(skill),
              'effect': _getSkillEffect(skill),
              'cost': _getSkillCost(skill),
              'requiredLevel': entry.key,
            });
          }
        }
      }
    }

    return skills;
  }

  int _getSkillCost(HeroLevelSkill skill) {
    // „Çπ„Ç≠„É´„ÅÆÁøíÂæó„Ç≥„Çπ„ÉàÔºàÁ®ÆÈ°û„Å´Âøú„Åò„Å¶Â§â„Åà„ÇãÔºâ
    switch (skill) {
      case HeroLevelSkill.berserker:
      case HeroLevelSkill.administrator:
        return 1;
      case HeroLevelSkill.tactician:
      case HeroLevelSkill.economist:
        return 2;
      case HeroLevelSkill.duelMaster:
      case HeroLevelSkill.engineer:
      case HeroLevelSkill.scholar:
        return 2;
      case HeroLevelSkill.siegeExpert:
      case HeroLevelSkill.negotiator:
      case HeroLevelSkill.inspiring:
        return 3;
      case HeroLevelSkill.spy:
      case HeroLevelSkill.strategist:
      case HeroLevelSkill.ambassador:
      case HeroLevelSkill.trainer:
        return 3;
    }
  }

  // „Çπ„Ç≠„É´Ë°®Á§∫Áî®„ÅÆ„Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„ÉâÁæ§
  String _getSkillDisplayName(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'ÁãÇÊà¶Â£´';
      case HeroLevelSkill.tactician:
        return 'Êà¶Ë°ìÂÆ∂';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°Âêç‰∫∫';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÂ∞ÇÈñÄÂÆ∂';
      case HeroLevelSkill.administrator:
        return 'Ë°åÊîøÂÆò';
      case HeroLevelSkill.economist:
        return 'ÁµåÊ∏àÂ≠¶ËÄÖ';
      case HeroLevelSkill.engineer:
        return 'ÊäÄË°ìËÄÖ';
      case HeroLevelSkill.scholar:
        return 'Â≠¶ËÄÖ';
      case HeroLevelSkill.negotiator:
        return '‰∫§Ê∏â‰∫∫';
      case HeroLevelSkill.spy:
        return 'Ë´úÂ†±Âì°';
      case HeroLevelSkill.ambassador:
        return 'Â§ß‰Ωø';
      case HeroLevelSkill.inspiring:
        return 'ÈºìËàû';
      case HeroLevelSkill.strategist:
        return 'Êà¶Áï•ÂÆ∂';
      case HeroLevelSkill.trainer:
        return 'Ë®ìÁ∑¥ÂÆò';
    }
  }

  String _getSkillDescription(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'Êà¶ÈóòÊôÇ„Å´ÁãÇÊà¶Â£´„ÅÆÂäõ„ÇíÁô∫ÊèÆ';
      case HeroLevelSkill.tactician:
        return 'ÈÉ®Èöä„ÅÆÊà¶Ë°ìÊåáÊèÆ„Å´Èï∑„Åë„Çã';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°„ÅÆÈÅî‰∫∫';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÊà¶„ÅÆ„Ç®„Ç≠„Çπ„Éë„Éº„Éà';
      case HeroLevelSkill.administrator:
        return 'ÂÑ™ÁßÄ„Å™Ë°åÊîøÊâãËÖï„ÇíÊåÅ„Å§';
      case HeroLevelSkill.economist:
        return 'ÁµåÊ∏àÊîøÁ≠ñ„Å´Á≤æÈÄö';
      case HeroLevelSkill.engineer:
        return 'Âª∫Ë®≠„ÉªÊäÄË°ìÈñãÁô∫„ÅÆÂ∞ÇÈñÄÂÆ∂';
      case HeroLevelSkill.scholar:
        return 'Â≠¶Âïè„ÉªÁ†îÁ©∂„ÅÆÁ¨¨‰∏Ä‰∫∫ËÄÖ';
      case HeroLevelSkill.negotiator:
        return 'Â§ñ‰∫§‰∫§Ê∏â„ÅÆÂêçÊâã';
      case HeroLevelSkill.spy:
        return 'Ë´úÂ†±Ê¥ªÂãï„ÅÆ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´';
      case HeroLevelSkill.ambassador:
        return 'ÂêåÁõüÈñ¢‰øÇ„ÅÆÁ∂≠ÊåÅ„Å´Èï∑„Åë„Çã';
      case HeroLevelSkill.inspiring:
        return 'ÈÉ®‰∏ã„ÅÆÂ£´Ê∞ó„ÇíÈ´ò„ÇÅ„Çã';
      case HeroLevelSkill.strategist:
        return 'Â§ßÂ±ÄÁöÑÊà¶Áï•„ÅÆÁ´ãÊ°àËÄÖ';
      case HeroLevelSkill.trainer:
        return 'ÂÖµÂ£´„ÅÆË®ìÁ∑¥ÊåáÂ∞éËÄÖ';
    }
  }

  String _getSkillIcon(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return '‚ö°';
      case HeroLevelSkill.tactician:
        return 'üéØ';
      case HeroLevelSkill.duelMaster:
        return '‚öîÔ∏è';
      case HeroLevelSkill.siegeExpert:
        return 'üè∞';
      case HeroLevelSkill.administrator:
        return 'üìã';
      case HeroLevelSkill.economist:
        return 'üí∞';
      case HeroLevelSkill.engineer:
        return '‚öôÔ∏è';
      case HeroLevelSkill.scholar:
        return 'üìö';
      case HeroLevelSkill.negotiator:
        return 'ü§ù';
      case HeroLevelSkill.spy:
        return 'üïµÔ∏è';
      case HeroLevelSkill.ambassador:
        return 'üèõÔ∏è';
      case HeroLevelSkill.inspiring:
        return '‚ú®';
      case HeroLevelSkill.strategist:
        return 'üß†';
      case HeroLevelSkill.trainer:
        return 'üèãÔ∏è';
    }
  }

  String _getSkillEffect(HeroLevelSkill skill) {
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'Êà¶ÈóòÂäõ+20%';
      case HeroLevelSkill.tactician:
        return 'ÈÉ®ÈöäÊåáÊèÆ+30%';
      case HeroLevelSkill.duelMaster:
        return '‰∏ÄÈ®éË®é„Å°ÂãùÁéá+50%';
      case HeroLevelSkill.siegeExpert:
        return 'ÊîªÂüéÊà¶+40%';
      case HeroLevelSkill.administrator:
        return 'ÂÜÖÊîøÂäπÁéá+25%';
      case HeroLevelSkill.economist:
        return 'ÂèéÂÖ•+20%';
      case HeroLevelSkill.engineer:
        return 'Âª∫Ë®≠ÈÄüÂ∫¶+30%';
      case HeroLevelSkill.scholar:
        return 'Á†îÁ©∂ÈÄüÂ∫¶+25%';
      case HeroLevelSkill.negotiator:
        return 'Â§ñ‰∫§ÊàêÂäüÁéá+30%';
      case HeroLevelSkill.spy:
        return 'ÊÉÖÂ†±ÂèéÈõÜ+40%';
      case HeroLevelSkill.ambassador:
        return 'ÂêåÁõüÁ∂≠ÊåÅ+25%';
      case HeroLevelSkill.inspiring:
        return 'ÈÉ®ÈöäÂ£´Ê∞ó+20%';
      case HeroLevelSkill.strategist:
        return 'ÂÖ®‰ΩìÊà¶Áï•+15%';
      case HeroLevelSkill.trainer:
        return 'ÂÖµÂ£´ÊàêÈï∑+25%';
    }
  }

  void _learnSkill(BuildContext context, Map<String, dynamic> skill) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('„Çπ„Ç≠„É´ÁøíÂæó: ${skill['name']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(skill['description']),
            const SizedBox(height: 12),
            Text('ÂäπÊûú: ${skill['effect']}'),
            Text('ÂøÖË¶ÅSP: ${skill['cost']}'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('„Ç≠„É£„É≥„Çª„É´'),
          ),
          ElevatedButton(
            onPressed: () {
              // „Çπ„Ç≠„É´ÁøíÂæó„ÇíÂÆüË°å - skill„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÁõ¥Êé•HeroLevelSkill„ÇíÂèñÂæó
              final heroSkill = skill['skill'] as HeroLevelSkill;
              final skillId = _getSkillIdFromEnum(heroSkill);
              final success = controller.learnHeroSkill(hero.id, skillId);
              Navigator.of(context).pop();
              if (success) {
                _showSkillLearnSuccess(context, skill);
              } else {
                _showSkillLearnError(context, skill);
              }
            },
            child: const Text('ÁøíÂæó'),
          ),
        ],
      ),
    );
  }

  void _showSkillLearnSuccess(BuildContext context, Map<String, dynamic> skill) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('${skill['name']}„ÇíÁøíÂæó„Åó„Åæ„Åó„ÅüÔºÅ'),
        backgroundColor: Colors.blue,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  void _showSkillLearnError(BuildContext context, Map<String, dynamic> skill) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('${skill['name']}„ÅÆÁøíÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  String _getSkillIdFromEnum(HeroLevelSkill skill) {
    // HeroLevelSkill„Åã„Çâ„Çπ„Ç≠„É´ID„Å´Â§âÊèõ
    switch (skill) {
      case HeroLevelSkill.berserker:
        return 'berserker_rage';
      case HeroLevelSkill.tactician:
        return 'advanced_tactics';
      case HeroLevelSkill.duelMaster:
        return 'duel_master';
      case HeroLevelSkill.siegeExpert:
        return 'siege_expert';
      case HeroLevelSkill.administrator:
        return 'administration_expert';
      case HeroLevelSkill.economist:
        return 'economist';
      case HeroLevelSkill.engineer:
        return 'engineer';
      case HeroLevelSkill.scholar:
        return 'scholar';
      case HeroLevelSkill.negotiator:
        return 'negotiator';
      case HeroLevelSkill.spy:
        return 'spy';
      case HeroLevelSkill.ambassador:
        return 'ambassador';
      case HeroLevelSkill.inspiring:
        return 'inspiring';
      case HeroLevelSkill.strategist:
        return 'strategist';
      case HeroLevelSkill.trainer:
        return 'trainer';
    }
  }
}

/// „Çπ„Ç≠„É´„Ç´„Éº„Éâ
class _SkillCard extends StatelessWidget {
  const _SkillCard({
    required this.skill,
    required this.isLearned,
    this.canLearn = false,
    this.onLearn,
  });

  final Map<String, dynamic> skill;
  final bool isLearned;
  final bool canLearn;
  final VoidCallback? onLearn;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isLearned
            ? Colors.green.shade50
            : canLearn
                ? Colors.blue.shade50
                : Colors.grey.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isLearned
              ? Colors.green.shade200
              : canLearn
                  ? Colors.blue.shade200
                  : Colors.grey.shade200,
        ),
      ),
      child: Row(
        children: [
          // „Çπ„Ç≠„É´„Ç¢„Ç§„Ç≥„É≥
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: isLearned
                  ? Colors.green.shade100
                  : canLearn
                      ? Colors.blue.shade100
                      : Colors.grey.shade100,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              skill['icon'] ?? 'üìñ',
              style: const TextStyle(fontSize: 20),
            ),
          ),
          const SizedBox(width: 12),

          // „Çπ„Ç≠„É´ÊÉÖÂ†±
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  skill['name'] ?? '',
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Text(
                  skill['description'] ?? '',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
                if (skill['effect'] != null)
                  Text(
                    skill['effect'],
                    style: TextStyle(
                      color: Colors.orange.shade700,
                      fontWeight: FontWeight.bold,
                      fontSize: 12,
                    ),
                  ),
              ],
            ),
          ),

          // „Ç¢„ÇØ„Ç∑„Éß„É≥
          if (isLearned)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.circular(12),
              ),
              child: const Text(
                'ÁøíÂæóÊ∏à„Åø',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
            )
          else if (canLearn && onLearn != null)
            ElevatedButton(
              onPressed: onLearn,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              ),
              child: Text('ÁøíÂæó (${skill['cost']}SP)'),
            )
          else
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.grey.shade400,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                skill['requiredLevel'] != null ? 'Lv.${skill['requiredLevel']}ÂøÖË¶Å' : 'SP‰∏çË∂≥',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                ),
              ),
            ),
        ],
      ),
    );
  }
}

/// Ë£ÖÂÇô„Çø„Éñ
class _HeroEquipmentTab extends StatelessWidget {
  const _HeroEquipmentTab({
    required this.hero,
    this.advancement,
    required this.controller,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    if (!hero.isRecruited) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.lock, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              '‰ª≤Èñì„Å´„Å™„Å£„Å¶„Åã„Çâ\nË£ÖÂÇô„ÅÆÁÆ°ÁêÜ„ÅåÂèØËÉΩ„Åß„Åô',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Ë£ÖÂÇô„Çπ„É≠„ÉÉ„ÉàË°®Á§∫
          _EquipmentSlotsSection(
            hero: hero,
            advancement: advancement,
            controller: controller,
          ),
          const SizedBox(height: 24),

          // Ë£ÖÂÇôÂäπÊûúË°®Á§∫
          _EquipmentEffectsSection(
            hero: hero,
            advancement: advancement,
          ),
          const SizedBox(height: 24),

          // Âà©Áî®ÂèØËÉΩË£ÖÂÇô
          _AvailableEquipmentSection(
            hero: hero,
            controller: controller,
          ),
        ],
      ),
    );
  }
}

/// Ë£ÖÂÇô„Çπ„É≠„ÉÉ„Éà„Çª„ÇØ„Ç∑„Éß„É≥
class _EquipmentSlotsSection extends StatelessWidget {
  const _EquipmentSlotsSection({
    required this.hero,
    this.advancement,
    required this.controller,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '‚öîÔ∏è Ë£ÖÂÇô„Çπ„É≠„ÉÉ„Éà',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 16),

            // Ë£ÖÂÇô„Çπ„É≠„ÉÉ„Éà
            _EquipmentSlot(
              slotName: 'Ê≠¶Âô®',
              slotIcon: '‚öîÔ∏è',
              equippedItem: _getEquippedItem('weapon'),
              onEquip: () => _showEquipmentSelection(context, 'weapon'),
            ),
            const SizedBox(height: 12),
            _EquipmentSlot(
              slotName: 'Èò≤ÂÖ∑',
              slotIcon: 'üõ°Ô∏è',
              equippedItem: _getEquippedItem('armor'),
              onEquip: () => _showEquipmentSelection(context, 'armor'),
            ),
            const SizedBox(height: 12),
            _EquipmentSlot(
              slotName: 'Ë£ÖË∫´ÂÖ∑',
              slotIcon: 'üíç',
              equippedItem: _getEquippedItem('accessory'),
              onEquip: () => _showEquipmentSelection(context, 'accessory'),
            ),
            const SizedBox(height: 12),
            _EquipmentSlot(
              slotName: 'ÊÑõÈ¶¨',
              slotIcon: 'üêé',
              equippedItem: _getEquippedItem('horse'),
              onEquip: () => _showEquipmentSelection(context, 'horse'),
            ),
          ],
        ),
      ),
    );
  }

  Map<String, dynamic>? _getEquippedItem(String slot) {
    // TODO: ÂÆüÈöõ„ÅÆË£ÖÂÇô„Éá„Éº„Çø„ÇíÂèñÂæó
    if (slot == 'weapon') {
      return {
        'name': 'ÈùíÈæçÂÅÉÊúàÂàÄ',
        'rarity': '‰ºùË™¨',
        'effect': 'Ê≠¶Âäõ+15',
      };
    }
    return null;
  }

  void _showEquipmentSelection(BuildContext context, String slot) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${_getSlotDisplayName(slot)}„ÇíÈÅ∏Êäû'),
        content: const SizedBox(
          width: 300,
          height: 400,
          child: Center(child: Text('Ë£ÖÂÇôÈÅ∏ÊäûÊ©üËÉΩÔºàÂÆüË£Ö‰∫àÂÆöÔºâ')),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Èñâ„Åò„Çã'),
          ),
        ],
      ),
    );
  }

  String _getSlotDisplayName(String slot) {
    switch (slot) {
      case 'weapon':
        return 'Ê≠¶Âô®';
      case 'armor':
        return 'Èò≤ÂÖ∑';
      case 'accessory':
        return 'Ë£ÖË∫´ÂÖ∑';
      case 'horse':
        return 'ÊÑõÈ¶¨';
      default:
        return slot;
    }
  }
}

/// Ë£ÖÂÇô„Çπ„É≠„ÉÉ„Éà
class _EquipmentSlot extends StatelessWidget {
  const _EquipmentSlot({
    required this.slotName,
    required this.slotIcon,
    this.equippedItem,
    required this.onEquip,
  });

  final String slotName;
  final String slotIcon;
  final Map<String, dynamic>? equippedItem;
  final VoidCallback onEquip;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onEquip,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey.shade300),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            // „Çπ„É≠„ÉÉ„Éà„Ç¢„Ç§„Ç≥„É≥
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: equippedItem != null ? Colors.orange.shade100 : Colors.grey.shade100,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                slotIcon,
                style: const TextStyle(fontSize: 20),
              ),
            ),
            const SizedBox(width: 12),

            // „Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    slotName,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                  ),
                  if (equippedItem != null)
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          equippedItem!['name'] ?? '',
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                        Text(
                          equippedItem!['effect'] ?? '',
                          style: TextStyle(
                            color: Colors.orange.shade700,
                            fontSize: 12,
                          ),
                        ),
                      ],
                    )
                  else
                    Text(
                      'Êú™Ë£ÖÂÇô',
                      style: TextStyle(
                        color: Colors.grey.shade600,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                ],
              ),
            ),

            // „Ç¢„ÇØ„Ç∑„Éß„É≥
            Icon(
              Icons.chevron_right,
              color: Colors.grey.shade400,
            ),
          ],
        ),
      ),
    );
  }
}

/// Ë£ÖÂÇôÂäπÊûú„Çª„ÇØ„Ç∑„Éß„É≥
class _EquipmentEffectsSection extends StatelessWidget {
  const _EquipmentEffectsSection({
    required this.hero,
    this.advancement,
  });

  final game.Hero hero;
  final AdvancedHero? advancement;

  @override
  Widget build(BuildContext context) {
    final equipmentBonus = _calculateEquipmentBonus();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'üìä Ë£ÖÂÇôÂäπÊûú',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            if (equipmentBonus.isEmpty)
              Container(
                padding: const EdgeInsets.all(16),
                width: double.infinity,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Text(
                  'Ë£ÖÂÇô„Å´„Çà„ÇãËÉΩÂäõ„Éú„Éº„Éä„Çπ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey),
                ),
              )
            else
              ...equipmentBonus.entries.map((entry) => Padding(
                    padding: const EdgeInsets.symmetric(vertical: 2),
                    child: Row(
                      children: [
                        Text(_getStatIcon(entry.key)),
                        const SizedBox(width: 8),
                        Text(entry.key),
                        const Spacer(),
                        Text(
                          '+${entry.value}',
                          style: TextStyle(
                            color: Colors.green.shade700,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  )),
          ],
        ),
      ),
    );
  }

  Map<String, int> _calculateEquipmentBonus() {
    // TODO: ÂÆüÈöõ„ÅÆË£ÖÂÇô„Éú„Éº„Éä„ÇπË®àÁÆó
    return {
      'Ê≠¶Âäõ': 15,
      'Áµ±Áéá': 5,
    };
  }

  String _getStatIcon(String stat) {
    switch (stat) {
      case 'Ê≠¶Âäõ':
        return '‚öîÔ∏è';
      case 'Áµ±Áéá':
        return 'üëë';
      case 'Áü•Âäõ':
        return 'üß†';
      case 'È≠ÖÂäõ':
        return '‚ú®';
      case 'Áæ©ÁêÜ':
        return '‚ù§Ô∏è';
      default:
        return 'üìä';
    }
  }
}

/// Âà©Áî®ÂèØËÉΩË£ÖÂÇô„Çª„ÇØ„Ç∑„Éß„É≥
class _AvailableEquipmentSection extends StatelessWidget {
  const _AvailableEquipmentSection({
    required this.hero,
    required this.controller,
  });

  final game.Hero hero;
  final WaterMarginGameController controller;

  @override
  Widget build(BuildContext context) {
    final availableEquipment = _getAvailableEquipment();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'üéí Âà©Áî®ÂèØËÉΩ„Å™Ë£ÖÂÇô',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            if (availableEquipment.isEmpty)
              Container(
                padding: const EdgeInsets.all(16),
                width: double.infinity,
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Text(
                  'Âà©Áî®ÂèØËÉΩ„Å™Ë£ÖÂÇô„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey),
                ),
              )
            else
              ...availableEquipment.map((equipment) => _EquipmentItem(
                    equipment: equipment,
                    onEquip: () => _equipItem(context, equipment),
                  )),
          ],
        ),
      ),
    );
  }

  List<Map<String, dynamic>> _getAvailableEquipment() {
    // TODO: ÂÆüÈöõ„ÅÆÂà©Áî®ÂèØËÉΩË£ÖÂÇô„Éá„Éº„Çø„ÇíÂèñÂæó
    return [
      {
        'name': 'ÈâÑÂâ£',
        'type': 'Ê≠¶Âô®',
        'rarity': '‰∏ÄËà¨',
        'effect': 'Ê≠¶Âäõ+5',
        'icon': '‚öîÔ∏è',
      },
      {
        'name': 'Èù©Èéß',
        'type': 'Èò≤ÂÖ∑',
        'rarity': '‰∏ÄËà¨',
        'effect': 'Èò≤Âæ°+3',
        'icon': 'üõ°Ô∏è',
      },
    ];
  }

  String _getEquipmentSlot(String type) {
    switch (type) {
      case 'Ê≠¶Âô®':
        return 'weapon';
      case 'Èò≤ÂÖ∑':
        return 'armor';
      case '„Ç¢„ÇØ„Çª„Çµ„É™„Éº':
        return 'accessory';
      case 'È¶¨':
        return 'horse';
      default:
        return 'weapon';
    }
  }

  String _getEquipmentId(String name) {
    switch (name) {
      case 'ÈâÑÂâ£':
        return 'iron_sword';
      case 'ÈãºÈâÑÂâ£':
        return 'steel_sword';
      case 'Èù©Èéß':
        return 'leather_armor';
      default:
        return name.toLowerCase().replaceAll(' ', '_');
    }
  }

  void _equipItem(BuildContext context, Map<String, dynamic> equipment) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Ë£ÖÂÇô: ${equipment['name']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Á®ÆÈ°û: ${equipment['type']}'),
            Text('ÂìÅË≥™: ${equipment['rarity']}'),
            Text('ÂäπÊûú: ${equipment['effect']}'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('„Ç≠„É£„É≥„Çª„É´'),
          ),
          ElevatedButton(
            onPressed: () {
              // Ë£ÖÂÇôÊ©üËÉΩ„ÇíÂÆüË£Ö
              final slot = _getEquipmentSlot(equipment['type']);
              final itemId = _getEquipmentId(equipment['name']);
              final success = controller.equipHeroItem(hero.id, slot, itemId);
              Navigator.of(context).pop();
              if (success) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('${equipment['name']}„ÇíË£ÖÂÇô„Åó„Åæ„Åó„Åü'),
                    backgroundColor: Colors.green,
                  ),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('${equipment['name']}„ÅÆË£ÖÂÇô„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            },
            child: const Text('Ë£ÖÂÇô'),
          ),
        ],
      ),
    );
  }
}

/// Ë£ÖÂÇô„Ç¢„Ç§„ÉÜ„É†
class _EquipmentItem extends StatelessWidget {
  const _EquipmentItem({
    required this.equipment,
    required this.onEquip,
  });

  final Map<String, dynamic> equipment;
  final VoidCallback onEquip;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: onEquip,
        borderRadius: BorderRadius.circular(8),
        child: Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            children: [
              // „Ç¢„Ç§„ÉÜ„É†„Ç¢„Ç§„Ç≥„É≥
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: _getRarityColor(equipment['rarity']),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  equipment['icon'] ?? 'üì¶',
                  style: const TextStyle(fontSize: 20),
                ),
              ),
              const SizedBox(width: 12),

              // „Ç¢„Ç§„ÉÜ„É†ÊÉÖÂ†±
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      equipment['name'] ?? '',
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    Text(
                      '${equipment['type']} - ${equipment['rarity']}',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                    Text(
                      equipment['effect'] ?? '',
                      style: TextStyle(
                        color: Colors.orange.shade700,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),

              // Ë£ÖÂÇô„Éú„Çø„É≥
              ElevatedButton(
                onPressed: onEquip,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                ),
                child: const Text('Ë£ÖÂÇô'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getRarityColor(String? rarity) {
    switch (rarity) {
      case '‰ºùË™¨':
        return Colors.orange.shade100;
      case 'Ëã±ÈõÑÁ¥ö':
        return Colors.purple.shade100;
      case 'Á®ÄÂ∞ë':
        return Colors.green.shade100;
      case 'ÂÑ™ËâØ':
        return Colors.blue.shade100;
      default:
        return Colors.grey.shade100;
    }
  }
}
